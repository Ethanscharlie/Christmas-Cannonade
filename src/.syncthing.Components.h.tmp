#pragma once
#include "Charlie2D.h"
#include "Component.h"
#include "Config.h"
#include "Entity.h"
#include "EntityBox.h"
#include "Vector2f.h"
#include "toBeEnginized.h"
#include <cmath>

class God;
void loadEndScene();
void loadGameScene();

class Gift : public Component {
public:
  void update(float deltaTime) override {
    Camera::setPosition(entity->get<entityBox>()->getBox().getCenter());

    Entity *tree = GameManager::getEntities("Tree")[0];
    if (entity->get<entityBox>()->getBox().checkCollision(
            tree->get<entityBox>()->getBox())) {

      if (LDTK::fullJSON["levels"].size() - 1 > currentLevel) {
        currentLevel++;
      } else {
        currentLevel = 0;
        loadEndScene();
        return;
      }

      for (Entity *entityO : GameManager::getAllObjects()) {
        if (entityO->checkComponent<God>())
          continue;
        if (entityO->tag == "canvas")
          continue;
        if (entityO->tag == "timerPanel") {
          std::cout << "Found" << std::endl;
          continue;
        }
        entityO->toDestroy = true;
      }

      GameManager::playSound(TREE_HIT_SOUND);

      LDTK::loadLevel(LDTK::fullJSON["levels"][currentLevel]["iid"], false);
    }

    checkKill("Kill");
    checkKill("Star");
  }

  void checkKill(std::string tag) {
    for (Entity *kill : GameManager::getEntities(tag)) {
      if (entity->get<entityBox>()->getBox().checkCollision(
              kill->get<entityBox>()->getBox())) {
        entity->toDestroy = true;
        GameManager::playSound(HIT_SPIKE_SOUND);
      }
    }
  }

  Entity *firedFrom = nullptr;
};

class Gravity : public Component {
public:
  void start() override { entity->add<physicsBody>(); }

  void update(float deltaTime) override {

    entity->get<physicsBody>()->velocity.y += gravity * deltaTime;
  }

  float gravity = 1500;
};

Entity *createGift(Vector2f position, Vector2f direction, float force,
                   Entity *firedFrom);

class Cannon : public Component {
public:
  void start() override {}

  void update(float deltaTime) override {
    if (hasGift) {
      rotation.lookAt(entity->get<entityBox>()->getBox().getCenter(),
                      InputManager::getMouseWorldPosition());
      entity->get<Sprite>()->angle = rotation;

      if (InputManager::checkInput("fire")) {
        fire();
        unarmedState();
      }

      float mouseDistance = entity->get<entityBox>()->getBox().getCenter().dist(
          InputManager::getMouseWorldPosition());
      float force = forceMultiplier * mouseDistance;
      if (force > maxForce) {
        force = maxForce;
      } else if (force < 300) {
        force = 300;
      }

      entity->get<entityBox>()->setScale({force / 10, 16});
      // entity->get<entityBox>()->setScale({48, 16});
    } else {
      entity->get<entityBox>()->setScale({48, 16});
    }

    if (GameManager::getEntities("Gift").size() > 0) {
      Entity *gift = GameManager::getEntities("Gift")[0];
      if (entity->get<entityBox>()->getBox().checkCollision(
              gift->get<entityBox>()->getBox()) &&
          gift->get<Gift>()->firedFrom != entity && !gift->toDestroy) {
        gift->toDestroy = true;
        hasGift = true;

        entity->get<Sprite>()->loadTexture(armedTexture, false);
      }
    }
  }

  void unarmedState() {
    hasGift = false;
    entity->get<Sprite>()->loadTexture(defaultTexture, false);
  }

  void fire() {
    float mouseDistance = entity->get<entityBox>()->getBox().getCenter().dist(
        InputManager::getMouseWorldPosition());
    float force = forceMultiplier * mouseDistance;
    if (force > maxForce) {
      force = maxForce;
    }

    GameManager::playSound(CANNON_FIRE_SOUND);

    createGift(entity->get<entityBox>()->getBox().getCenter(),
               rotation.getVector(), force, entity);
  }

  Angle rotation;
  bool hasGift = false;

  // const float forceMultiplier = 5;
  const float forceMultiplier = 8;
  // const float maxForce = 800;
  const float maxForce = 800;
  const std::string defaultTexture = "img/cannon.png";
  const std::string armedTexture = "img/armedCannon.png";
};

class God : public Component {
public:
  void update(float deltaTime) {
    if (InputManager::checkInput("jumpTrigger")) {
      GameManager::playSound(GIFT_RESET_SOUND);
      reset();
    }

    if (InputManager::keys[SDLK_r]) {
      currentLevel = 0;
      loadGameScene();
    }

    if (timerPanel != nullptr) {
      float runTime = (SDL_GetTicks() - runTimerStart) / 1000.0f;
      runTime = std::round(runTime * 100.0f) / 100.0f;
      timerPanel->get<Text>()->text = floatToString(runTime);
    }
  }

  void reset() {
    for (Gift *gift : GameManager::getComponents<Gift>()) {
      gift->entity->toDestroy = true;
    }

    for (Cannon *cannon : GameManager::getComponents<Cannon>()) {
      cannon->unarmedState();
    }

    createGift(GameManager::getEntities("GiftSpawn")
                   .back()
                   ->get<entityBox>()
                   ->getBox()
                   .getCenter(),
               {0, 0}, 0, nullptr);
  }

  Entity *timerPanel = nullptr;
};

class StartMenuDetecter : public Component {
public:
  void update(float deltaTime) override {
    if (InputManager::checkInput("jump")) {
      loadGameScene();
    }
  }
};

class MovePoint : public Component {
public:
  void update(float deltaTime) override {
    Vector2f currentPosition = entity->get<entityBox>()->getBox().getCenter();
    if (movingToEnd) {
      // Check Past
      Vector2f direction = (endPoint - currentPosition).normalize();
      entity->get<entityBox>()->changePosition(direction * speed * deltaTime);


      if (currentPosition.dist(endPoint) < lowSpeed)
        movingToEnd = false;
    } else {

      // Check Past
      Vector2f direction = (startPoint - currentPosition).normalize();
      entity->get<entityBox>()->changePosition(direction * speed * deltaTime);

      if (currentPosition.dist(startPoint) < lowSpeed)
        movingToEnd = true;
    }
  }

  bool movingToEnd = true;

  float speed = 60.0f;
  Vector2f startPoint;
  Vector2f endPoint;

  const float lowSpeed = 1;
};
